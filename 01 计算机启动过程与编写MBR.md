## 1 BIOS启动过程

### 1.1 BIOS程序存储在ROM中，ROM映射地址段为:

|起始|结束|大小|描述|
|-|-|-|-|
|0xFFFF0|0xFFFFF|16B|0xFFFF0是BIOS入口地址，对应跳转指令 jmp f000:e05b|
|0xF0000|0xFFFEF|64KB-16B|BIOS程序的地址范围|

### 1.2 CPU启动时，默认 cs : ip 为 0xf000 : 0xfff0。

### 1.3 通过 地址加法器 得到20位地址 0xffff0。

### 1.3 CPU读取地址 0xffff0 对应的BIOS指令 jmp f000:e05b。

### 1.4 CPU 跳转至地址 0xfe05b 读取指令，BIOS代码开始运行。

### 1.5 BIOS开始检测内存、显卡等外设，当检测通过，初始化好硬件后，开始在内存中0x000 ~ 0x3FF建立数据结构，中断向量表IVT并填写中断例程。
|起始|结束|大小|描述|
|-|-|-|-|
|0x000|0x3FF|1KB|Interrupt Vector Table(中断向量表)|

### 1.6 检测完成后，调用BIOS中断0x19h 汇编语句为 call int 19h，此中断函数检测计算机有多少硬盘和软盘。

### 1.7 检测到任何可用的磁盘后，校验磁盘 0盘 0道 1扇区（1扇区 可以存储 512 Byte），当扇区最后两个字节内容分别是魔数 0x55 和 0xaa，BIOS认为此扇区存在可执行的主引导记录（MBR）。

### 1.8 BIOS将MBR加载至内存（DRAM），对应地址 0x7c00 ~ 0x7dff
|起始|结束|大小|描述|
|-|-|-|-|
|0x7C00|0x7DFF|512KB|BIOS加载 0盘 0道 1扇区 MBR 到此地址段|

### 1.9 BIOS 跳转至 0x7c00 汇编语句为 jmp 0 : 0x7c00。地址跳转至0x7c00后，启动由BIOS程序转到MBR。

## 2 启动 Main Boot Record（MBR） 主引导记录

### 2.1 MBR汇编程序

|汇编语句|初始化说明|
|-|-|
|mov ax,cs|MBR在地址0x7c00对应的语句。因为BIOS最后的语句是 jmp 0:0x7c00 所以cs为0，ip为0x7c00。ax被cs赋值也为0。|
|mov ds,ax mov es,ax mov ss,ax mov fs,ax|ds,es,ss,fs 以 ax 值初始化|
|mov sp,0x7c00|sp堆栈指针寄存器，栈顶指针地址为0x7c00|

```assembler
; 主引导程序
;--------------------------------------------------------------------------------
SECTION MBR vstart=0x7c00 ; 告诉编译器把其后面的汇编语句对应于地址编码为0x7c00
	mov ax,cs
	mov ds,ax
	mov es,ax
	mov ss,ax
	mov fs,ax
	mov sp,0x7c00

;--------------------------------------------------------------------------------
; 中断 INT 0x10	功能号: AH = 0x06	功能描述: 上卷窗口，达到清屏效果
;--------------------------------------------------------------------------------
; 输入:
; AH = 功能号 0x06
; AL = 上卷行数(如果为0，表示全窗口上卷)
; BH = 上卷行属性
; (CL,CH) = 窗口左上角位置(x,y)
; (DL,DH) = 窗口右下角位置(x,y)
; 输出：无

	mov ax, 0x600   ; AX = AH(高8位) + AL（低8位） AH = 06h AL = 00h
	mov bx, 0x700   ; BX = BH + BL BH = 07h
	mov cx, 0       ; CX = CH + CL 即左上角(0,0)
	mov dx, 0x184f	; DX = DH + CL 即右下角(80,25)
					; VGA文本模式中,一行只能容纳80个字符, 显示25行
					; 下标从0开始, 所以0x18=24（共25行）, 0x4f=79（共80列）
	int 0x10	    ; 将以上参数传入寄存器，然后执行 int 0x10 调用中断


; 获取光标位置，在光标位置处打印字符 
;--------------------------------------------------------------------------------
; 中断 INT 0x10	功能号: AH = 0x03	功能描述: 获取光标位置
;--------------------------------------------------------------------------------
; 输入:
; AH = 功能号 0x03
; BH = 待获取光标的页号
; 输出：
;      CX = CH + CL, CH光标开始行 CL光标结束行
;      DX = DH + DL, DH光标所在行号 DL光标所在列号     

	mov ah, 3	
	mov bh, 0       ; 0为80x25窗口的第1页
	int 0x10	    ; 输出 CX DX

; 在光标位置处打印字符 
;--------------------------------------------------------------------------------
; 中断 INT 0x10	功能号: AH = 0x13（message）	功能描述: 写字符串
;--------------------------------------------------------------------------------
; 输入:
; AX = 功能号 0x13 (message)

	mov ax, message ; message db "1 MBR"
	mov bp, ax	    ; es:bp为串首地址，es与cs一致 因为已初始化 
	
; 光标位置使用DX（DH光标所在行号 DL光标所在列号），忽略CX中的光标位置信息  
	mov cx, 5	    ; cx 为字符串长度，不包括结束符 0 的字符个数
	mov ax, 0x1301	; AH = 功能号 13h， 写字符串
					; AL = 01h，写字符方式01表示 显示字符串，光标跟随移动 
	mov bx, 0x2	    ; BH = 00h 存储要显示的页面，0即第1页 
			        ; BL = 02h 字符属性，02h即黑底绿字
	int 0x10	    
          
;--------------------------------------------------------------------------------
	jmp $		; 使程序悬停在此
;--------------------------------------------------------------------------------

	message db "1 MBR"    ; 定义打印的字符串
	times 510-($-$$) db 0 ; $$是SECTION的起始地址,$是本行地址, $-$$是地址偏移量
						  ; 512字节的最后两位要存储0x55aa，本扇区剩余的字节用0填满
	db 0x55, 0xaa         ; 最后两字节存储0x55aa
	
```

### 2.2 使用NASM 汇编平台，编译MBR

```shell
nasm -o mbr.bin mbr.s //生产 512字节的 mbr.bin 文件
```

### 2.3 Linux DD命令 写入mbr.bin 至 磁盘任何扇区

```shell
dd if=/your_path/mbr.bin of=/your_path/bochs/hd60M.img bs=512 count=1 conv=notrunc
```

==if = FILE== : 指定要读取的文件
==of=FILE== : 指定要写入的文件
==bs=BYTES== : 指定块的大小
==count=BLOCKS== : 指定拷贝的块数
==seek=BLOCKS== : 指定把块输出到文件时跳过多少个块
==conv=CONVS== : 指定如何转换文件，建议 conv=notrunc

### 2.4 启动 bochs
```shell
bin/bochs -f bochsrc.disk

......
<bochs:1> c
......
```

![[MBR.png]]